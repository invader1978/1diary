<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<title>Invader Stable v8 (Mobile Single Shot / FAST + Pools + Cached Enemies)</title>
<style>
  html,body{
    margin:0;padding:0;background:#000;overflow:hidden;
    touch-action:none;
    overscroll-behavior:none;
    -webkit-overflow-scrolling:auto;
    -webkit-text-size-adjust:100%;
  }
  canvas{position:fixed;inset:0;display:block;touch-action:none;pointer-events:auto}

  #hud{
    position:fixed;top:8px;left:8px;z-index:10;color:#fff;
    font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    user-select:none;pointer-events:none;
  }

  #pauseBtn{
    position:fixed;top:10px;right:10px;z-index:80;
    padding:8px 12px;font:700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff;background:rgba(0,0,0,.55);
    border:2px solid rgba(255,255,255,.25);border-radius:10px;
    cursor:pointer;pointer-events:auto;user-select:none;
    touch-action:manipulation;
    -webkit-tap-highlight-color: transparent;
  }

  #msg{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:#fff;font:700 40px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    text-shadow:0 2px 0 rgba(0,0,0,.5);
    z-index:40;pointer-events:none;text-align:center;white-space:pre-line;
  }

  /* ===== Mobile controls ===== */
  .controls{position:fixed;inset:0;z-index:70;pointer-events:none}

  #stickBase,#stickKnob{
    position:fixed;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    user-select:none;
    -webkit-user-select:none;
    -webkit-touch-callout:none;
    -webkit-tap-highlight-color: transparent;
    transform: translateZ(0);
  }
  #stickBase{
    width:140px;height:140px;left:22px;bottom:22px;
    background:rgba(40,40,40,.55);
    border:2px solid rgba(255,255,255,.25);
  }
  #stickKnob{
    width:74px;height:74px;left:22px;bottom:22px;
    background:rgba(0,0,0,.65);
    border:2px solid rgba(255,255,255,.20);
  }

  #shootBtn{
    position:fixed;width:120px;height:120px;
    right:22px;bottom:28px;border-radius:50%;
    pointer-events:auto;
    touch-action:none !important;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    transform: translateZ(0);
    -webkit-appearance:none;
    appearance:none;
    outline:none;

    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.35),rgba(255,0,0,.9));
    border:2px solid rgba(255,255,255,.25);
  }
  #shootLabel{
    position:fixed;right:22px;bottom:160px;
    color:#fff;font:800 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px;border:2px solid rgba(255,255,255,.25);
    border-radius:10px;background:rgba(0,0,0,.45);pointer-events:none;
  }

  @media (pointer: fine) {
    .controls{display:none;}
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="hud">
  SCORE <span id="score">0</span> /
  WAVE <span id="wave">1</span><br>
  LIFE <span id="life">❤️❤️❤️</span>
</div>

<button id="pauseBtn" type="button">PAUSE</button>
<div id="msg"></div>

<div class="controls" id="controls">
  <div id="stickBase"></div>
  <div id="stickKnob"></div>
  <button id="shootBtn" type="button" aria-label="shoot"></button>
  <div id="shootLabel">SHOT</div>
</div>

<script>
(() => {
  "use strict";

  /* =========================================================
     v8 改修内容（このファイル内で完結）
     1) 敵探索のキャッシュ化（aliveIds / aliveStats を保持、必要時のみ再計算）
     2) 弾・爆発のオブジェクトプール（GC負荷低減）
     3) 最後の1体の速度を現実的に（運ゲー回避）
     4) アーキテクチャ整理（State / Systems / Renderer に分割）
  ========================================================= */

  const UA = navigator.userAgent || "";
  const IS_IOS = /iP(hone|ad|od)/.test(UA);

  if (IS_IOS) {
    ["gesturestart","gesturechange","gestureend","dblclick"].forEach(t => {
      document.addEventListener(t, e => e.preventDefault(), { passive:false });
    });
  }

  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha:false }) || cv.getContext("2d");

  const scoreEl = document.getElementById("score");
  const waveEl  = document.getElementById("wave");
  const lifeEl  = document.getElementById("life");
  const msgEl   = document.getElementById("msg");
  const pauseBtn = document.getElementById("pauseBtn");

  const controls = document.getElementById("controls");
  const stickBase = document.getElementById("stickBase");
  const stickKnob = document.getElementById("stickKnob");
  const shootBtn = document.getElementById("shootBtn");

  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const aabb = (ax,ay,aw,ah,bx,by,bw,bh) =>
    !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);

  function resizeCanvas(){ cv.width = innerWidth; cv.height = innerHeight; }

  function calcU(){ if (innerWidth>=1200) return 7; if (innerWidth>=800) return 6; return 4; }
  function isCoarse(){
    return (window.matchMedia && window.matchMedia("(pointer: coarse)").matches)
      || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
  }

  const SHIP = [
    "000010000","000111000","000111000",
    "011111110","111111111","111111111","111111111"
  ];

  const ENEMY_TYPES = [
    { a:["0100010","1111111","1011101","0100010"], b:["0100010","1111111","0101010","1010101"] },
    { a:["0011100","0111110","1101011","0111110"], b:["0011100","1111111","0101010","1010101"] },
    { a:["0110110","1111111","0101010","1010101"], b:["0011100","0111110","1101011","0111110"] },
    { a:["0011100","1111111","1010101","0100010"], b:["0011100","0111110","0101010","1010101"] }
  ];

  const SHIELD = [
    "00111100","01111110","11111111","11111111","11111111","11000011"
  ];

  function drawBitmap(lines, x, y, scale, color){
    ctx.fillStyle = color;
    for(let r=0;r<lines.length;r++){
      const row = lines[r];
      for(let c=0;c<row.length;c++){
        if(row[c]==="1") ctx.fillRect(x+c*scale, y+r*scale, scale, scale);
      }
    }
  }

  /* =========================
     Object Pool (汎用)
  ========================= */
  class Pool {
    constructor(createFn, resetFn, initial=64){
      this._create = createFn;
      this._reset = resetFn || (()=>{});
      this._free = [];
      this._active = [];
      for(let i=0;i<initial;i++) this._free.push(this._create());
    }
    acquire(){
      const o = this._free.length ? this._free.pop() : this._create();
      this._active.push(o);
      return o;
    }
    releaseAt(i){
      const o = this._active[i];
      // swap-remove
      this._active[i] = this._active[this._active.length-1];
      this._active.pop();
      this._reset(o);
      this._free.push(o);
    }
    get active(){ return this._active; }
    clear(){
      for(let i=this._active.length-1;i>=0;i--){
        this.releaseAt(i);
      }
    }
  }

  /* =========================
     State (ゲームの状態)
  ========================= */
  class GameState {
    constructor(){
      this.U = calcU();
      this.isMobile = isCoarse();

      this.shipW = 0; this.shipH = 0;
      this.enemyW = 0; this.enemyH = 0;
      this.shieldW = 0; this.shieldH = 0;

      this.score = 0;
      this.wave = 1;
      this.life = 3;

      this.ready = true;
      this.clearing = false;
      this.over = false;
      this.paused = false;

      this.hitStop = 0;
      this._pendingGameOver = false;

      this.invincible = 0;
      this.safeTimer = 0;

      this.holdL = false;
      this.holdR = false;
      this.playerCanShoot = true;

      this.playerBottomPx = 70;
      this.px = innerWidth/2;

      this.stars = [];

      this.cols = 11;
      this.rows = 5;

      this.fx = 0; this.fy = 0; this.dir = 1;
      this.prevFx = 0; this.prevFy = 0;

      this.enemyInitialCount = 0;
      this.enemyFrame = 0;
      this.enemyAnimTick = 0;
      this.enemyShootTick = 0;
      this.moveAcc = 0;
      this.wallPause = 0;

      // hpGrid はそのまま維持（描画・判定に便利）
      this.hpGrid = [];

      // 敵探索キャッシュ
      // aliveIds: 生存敵の id (r*cols+c) の配列
      // aliveIndex: id -> aliveIds 内の index（削除をO(1)）
      // aliveStats: minC/maxC/maxR/count（壁判定など）
      this.aliveIds = [];
      this.aliveIndex = [];
      this.aliveStats = { minC:0, maxC:this.cols-1, maxR:this.rows-1, count:0 };
      this.aliveDirty = true; // true の時のみ stats を再計算

      this.shields = [];
      this.shieldBoxes = [];

      this.shieldContactTick = 0;
      this.shieldContactEvery = 3;

      this.BW = 4;
      this.BH = 10;

      this.colors = {
        shield: () => "#ff3333",
        player: () => "#44ff88",
        row: ["#ff4d4d","#ffb84d","#ffff4d","#4dff4d","#4dd2ff"]
      };
    }

    updateLifeHud(){
      lifeEl.textContent = "❤️".repeat(Math.max(0, this.life));
    }

    playerTopY(){
      return innerHeight - this.playerBottomPx - this.shipH;
    }

    clampPlayer(){
      this.px = clamp(this.px, this.shipW/2, innerWidth - this.shipW/2);
    }

    recalcSizes(){
      this.shipW = SHIP[0].length * this.U;
      this.shipH = SHIP.length * this.U;

      const margin = 12;
      const minGapX = 0.90 * this.U;
      const availW = Math.max(120, innerWidth - margin*2);
      const maxEnemyW = (availW - (this.cols-1)*minGapX) / this.cols;
      const scale = this.isMobile ? 0.78 : 0.86;
      const targetW = maxEnemyW * scale;

      this.enemyW = clamp(targetW, 2.6*this.U, 5.5*this.U);
      this.enemyH = this.enemyW * (4/7);

      this.shieldW = 8*this.U;
      this.shieldH = 6*this.U;
    }

    resetStars(){
      this.stars = [...Array(120)].map(() => ({
        x:Math.random()*innerWidth,
        y:Math.random()*innerHeight,
        s:0.6+Math.random()*1.2
      }));
    }

    formationMetrics(){
      const minGapX = 0.90*this.U, minGapY = 1.10*this.U;
      const stepX = this.enemyW + minGapX;
      const stepY = this.enemyH + minGapY;
      const totalW = this.cols*this.enemyW + (this.cols-1)*minGapX;
      const baseY = Math.max(90, innerHeight*0.22);
      return { stepX, stepY, totalW, baseY };
    }

    rowKillScore(r){
      return (this.rows - r) * 10;
    }

    enemyProfile(){
      const fireInterval = Math.max(22, Math.floor(140 - (this.wave-1) * 8));
      const maxBullets = Math.min(12, 2 + Math.floor((this.wave-1) / 4));
      const burst = Math.min(3, 1 + Math.floor((this.wave-1) / 6));
      return { fireInterval, maxBullets, burst };
    }

    buildShieldBits(){
      const h = SHIELD.length, w = SHIELD[0].length;
      const bits = Array.from({length:h}, (_,r)=>Array.from({length:w},(_,c)=>SHIELD[r][c]==="1"));
      return {bits,w,h};
    }

    computeShieldLayout(){
      const topMin = 40;
      const gapFromPlayer = 14;
      const defaultOffset = 80;

      const playerY = this.playerTopY();
      let y = playerY - defaultOffset;

      const maxY = playerY - this.shieldH - gapFromPlayer;
      y = Math.min(y, maxY);
      y = Math.max(y, topMin);

      if(maxY < topMin){
        y = Math.max(0, maxY);
      }

      const xs = [0.2,0.4,0.6,0.8];
      return xs.map(v => ({ x: innerWidth * v - this.shieldW/2, y }));
    }
  }

  /* =========================
     Enemy System（キャッシュ化）
  ========================= */
  class EnemySystem {
    constructor(state){
      this.s = state;
    }

    _rebuildAliveCache(){
      const s = this.s;
      const total = s.rows * s.cols;
      s.aliveIds.length = 0;
      s.aliveIndex = Array(total).fill(-1);

      for(let r=0;r<s.rows;r++){
        for(let c=0;c<s.cols;c++){
          if(s.hpGrid[r][c] > 0){
            const id = r*s.cols + c;
            s.aliveIndex[id] = s.aliveIds.length;
            s.aliveIds.push(id);
          }
        }
      }
      s.aliveDirty = true;
      this._refreshAliveStatsIfNeeded();
      s.enemyInitialCount = s.aliveIds.length;
    }

    _refreshAliveStatsIfNeeded(){
      const s = this.s;
      if(!s.aliveDirty) return;
      s.aliveDirty = false;

      let minC = s.cols, maxC = -1, maxR = -1;
      for(let i=0;i<s.aliveIds.length;i++){
        const id = s.aliveIds[i];
        const r = (id / s.cols) | 0;
        const c = id - r*s.cols;
        if(c < minC) minC = c;
        if(c > maxC) maxC = c;
        if(r > maxR) maxR = r;
      }
      if(maxC < 0){
        minC = 0; maxC = s.cols-1; maxR = s.rows-1;
      }
      s.aliveStats = { minC, maxC, maxR, count: s.aliveIds.length };
    }

    spawnEnemies(){
      const s = this.s;
      s.cols = 11; s.rows = 5;
      const hp2 = (s.wave >= 4);

      s.hpGrid = Array.from({length:s.rows}, () =>
        Array.from({length:s.cols}, () => 1)
      );

      if (hp2) {
        for (let r=0;r<Math.min(2,s.rows);r++){
          for (let c=0;c<s.cols;c++) s.hpGrid[r][c] = 2;
        }
      }

      const { totalW, baseY } = s.formationMetrics();
      s.fx = (innerWidth - totalW)/2;
      s.fy = baseY;
      s.dir = 1;

      s.moveAcc = 0;
      s.wallPause = 0;

      s.enemyFrame = 0;
      s.enemyAnimTick = 0;
      s.enemyShootTick = 0;

      this._rebuildAliveCache();
    }

    // kill 処理：O(1)で aliveIds から除去
    onEnemyDamagedOrKilled(r,c){
      const s = this.s;
      if(s.hpGrid[r][c] > 0) return;

      const id = r*s.cols + c;
      const idx = s.aliveIndex[id];
      if(idx < 0) return;

      const lastId = s.aliveIds[s.aliveIds.length-1];
      s.aliveIds[idx] = lastId;
      s.aliveIndex[lastId] = idx;
      s.aliveIds.pop();
      s.aliveIndex[id] = -1;

      s.aliveDirty = true;
    }

    countAlive(){
      return this.s.aliveIds.length;
    }

    randomAliveRC(){
      const s = this.s;
      const n = s.aliveIds.length;
      if(!n) return null;
      const id = s.aliveIds[(Math.random()*n)|0];
      const r = (id / s.cols) | 0;
      const c = id - r*s.cols;
      return {r,c};
    }

    updateAnim(){
      const s = this.s;
      s.enemyAnimTick++;
      if(s.enemyAnimTick >= 28){
        s.enemyAnimTick = 0;
        s.enemyFrame = 1 - s.enemyFrame;
      }
    }

    getAliveStats(){
      this._refreshAliveStatsIfNeeded();
      return this.s.aliveStats;
    }
  }

  /* =========================
     Shield System（現状維持）
  ========================= */
  class ShieldSystem {
    constructor(state){
      this.s = state;
    }

    spawnShields(){
      const s = this.s;
      s.shields.length = 0;
      const proto = s.buildShieldBits();
      const layout = s.computeShieldLayout();
      for (let i=0;i<layout.length;i++){
        const {x,y} = layout[i];
        const bits = proto.bits.map(row=>row.slice());
        s.shields.push({x,y,bits,w:proto.w,h:proto.h});
      }
      this.rebuildShieldBoxes();
    }

    relayoutShields(){
      const s = this.s;
      if(!s.shields.length){
        this.spawnShields();
        return;
      }
      const layout = s.computeShieldLayout();
      for(let i=0;i<s.shields.length && i<layout.length;i++){
        s.shields[i].x = layout[i].x;
        s.shields[i].y = layout[i].y;
      }
      this.rebuildShieldBoxes();
    }

    rebuildShieldBoxes(){
      const s = this.s;
      s.shieldBoxes = s.shields.map(sh => ({
        x:sh.x, y:sh.y, w:s.shieldW, h:s.shieldH,
        ref:sh
      }));
    }

    shieldHitAndDamage(bx,by,bw,bh){
      const s = this.s;
      if (!s.shields.length) return false;

      const cx = bx + bw/2;
      let best = null;
      let bestD = Infinity;
      for (let i=0;i<s.shieldBoxes.length;i++){
        const box = s.shieldBoxes[i];
        const mid = box.x + box.w/2;
        const d = Math.abs(cx - mid);
        if (d < bestD) { bestD = d; best = box; }
      }

      const tryDamage = (box) => {
        if(!aabb(bx,by,bw,bh, box.x,box.y, box.w,box.h)) return false;
        const sh = box.ref;

        const rx = clamp(Math.floor(((bx+bw/2)-sh.x)/s.U), 0, sh.w-1);
        const ry = clamp(Math.floor(((by+bh/2)-sh.y)/s.U), 0, sh.h-1);

        const cand=[];
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          const cx=rx+dx, cy=ry+dy;
          if(cy>=0&&cy<sh.h&&cx>=0&&cx<sh.w&&sh.bits[cy][cx]) cand.push([cy,cx]);
        }
        if(cand.length){
          const [cy,cx]=cand[(Math.random()*cand.length)|0];
          sh.bits[cy][cx]=false;
        }
        return true;
      };

      if (best && tryDamage(best)) return true;

      for (let i=0;i<s.shieldBoxes.length;i++){
        const box = s.shieldBoxes[i];
        if (box === best) continue;
        if (tryDamage(box)) return true;
      }
      return false;
    }

    damageShieldRandom(shield, hits){
      hits = Math.max(0, hits|0);
      if(!hits) return;
      let attempts = hits * 10;
      while(hits > 0 && attempts-- > 0){
        const r = (Math.random() * shield.h) | 0;
        const c = (Math.random() * shield.w) | 0;
        if(shield.bits[r][c]){
          shield.bits[r][c] = false;
          hits--;
        }
      }
    }
  }

  /* =========================
     Projectile System（プール化）
  ========================= */
  class ProjectileSystem {
    constructor(state, enemySystem, shieldSystem, effects){
      this.s = state;
      this.enemies = enemySystem;
      this.shields = shieldSystem;
      this.fx = effects;

      const resetBullet = (b)=>{ b.x=0; b.y=0; b.v=0; };
      const resetBoom = (p)=>{ p.x=0; p.y=0; p.vx=0; p.vy=0; p.t=0; };

      // ざっくり初期容量（端末により増える）
      this.playerBullets = new Pool(
        ()=>({x:0,y:0,v:0}),
        resetBullet,
        32
      );
      this.enemyBullets = new Pool(
        ()=>({x:0,y:0,v:0}),
        resetBullet,
        64
      );
      this.booms = new Pool(
        ()=>({x:0,y:0,vx:0,vy:0,t:0}),
        resetBoom,
        128
      );
    }

    clearAll(){
      this.playerBullets.clear();
      this.enemyBullets.clear();
      this.booms.clear();
    }

    boom(x,y){
      for(let i=0;i<10;i++){
        const p = this.booms.acquire();
        p.x = x; p.y = y;
        p.vx = (Math.random()-.5)*5;
        p.vy = (Math.random()-.5)*5;
        p.t = 18;
      }
    }

    shootPlayerOnce(){
      const s = this.s;
      if(s.paused) return;
      if(s.ready || s.clearing || s.over) return;
      const b = this.playerBullets.acquire();
      b.x = s.px - s.BW/2;
      b.y = s.playerTopY();
      b.v = -10;
    }

    enemyShoot(){
      const s = this.s;
      if(s.paused) return;
      if(s.ready || s.clearing || s.over) return;

      const prof = s.enemyProfile();
      if(this.enemyBullets.active.length >= prof.maxBullets) return;

      const pick = this.enemies.randomAliveRC();
      if(!pick) return;

      const {r,c} = pick;
      const {stepX,stepY} = s.formationMetrics();
      const ex = s.fx + c*stepX, ey = s.fy + r*stepY;

      const baseV = (s.isMobile ? 5 : 7);
      const add = Math.min(3, (s.wave-1) * 0.18);
      const v = baseV + add;

      const shots = Math.min(prof.burst, prof.maxBullets - this.enemyBullets.active.length);
      for(let k=0;k<shots;k++){
        const spread = (k - (shots-1)/2) * (s.BW + 2);
        const b = this.enemyBullets.acquire();
        b.x = ex + s.enemyW/2 - s.BW/2 + spread;
        b.y = ey + s.enemyH;
        b.v = v;
      }
    }

    update(dt){
      const s = this.s;
      const pbs = this.playerBullets.active;
      for(let i=pbs.length-1;i>=0;i--){
        const b = pbs[i];
        b.y += b.v*(dt*0.06);
        if(b.y < -20){
          this.playerBullets.releaseAt(i);
        }
      }

      const ebs = this.enemyBullets.active;
      for(let i=ebs.length-1;i>=0;i--){
        const b = ebs[i];
        b.y += b.v*(dt*0.06);
        if(b.y > innerHeight + 30){
          this.enemyBullets.releaseAt(i);
        }
      }

      const booms = this.booms.active;
      for(let i=booms.length-1;i>=0;i--){
        const p = booms[i];
        p.x += p.vx;
        p.y += p.vy;
        p.t--;
        if(p.t <= 0){
          this.booms.releaseAt(i);
        }
      }
    }
  }

  /* =========================
     Collision System
  ========================= */
  class CollisionSystem {
    constructor(state, enemies, shields, projectiles){
      this.s = state;
      this.enemies = enemies;
      this.shields = shields;
      this.pj = projectiles;
    }

    // 体当たり演出：ヒットした瞬間に「ピタ止め」してからGAME OVER
    triggerRamming(contactFy){
      const s = this.s;
      if(s.over) return;
      s.fy = contactFy;

      s.hitStop = 200;
      if(s._pendingGameOver) return;
      s._pendingGameOver = true;

      setTimeout(() => {
        s.hitStop = 0;
        s._pendingGameOver = false;
        this.gameOver();
      }, 200);
    }

    gameOver(){
      const s = this.s;
      if(s.over) return;
      s.over = true;
      s.paused = false;
      pauseBtn.textContent = "PAUSE";
      msgEl.innerHTML = "GAME OVER<br>Tap or Enter";
      s.holdL = false;
      s.holdR = false;
    }

    nextWave(){
      const s = this.s;
      s.clearing = true;
      if(!s.paused) msgEl.textContent = "CLEAR!";
      setTimeout(() => {
        if(s.paused) return;
        msgEl.textContent = "";
        s.wave++;
        waveEl.textContent = s.wave;
        s.clearing = false;
        this.enemies.spawnEnemies();
        this.shields.spawnShields();
        this.showReady();
      }, 900);
    }

    showReady(){
      const s = this.s;
      clearTimeout(window._msgTimer);
      if(!s.paused) msgEl.textContent = "";
      s.ready = true;
      s.safeTimer = Math.floor(s.wave * 0.5 * 60);
      window._msgTimer = setTimeout(() => {
        if(!s.over && !s.paused) msgEl.textContent = "";
        s.ready = false;
      }, 900);
    }

    detect(){
      const s = this.s;
      if(s.paused) return;
      if(s.hitStop > 0) return;

      // 敵がシールドに触れている間：少しずつ削る（aliveIdsのみで判定）
      s.shieldContactTick++;
      if(s.shieldContactTick % s.shieldContactEvery === 0 && s.shieldBoxes.length){
        const {stepX, stepY} = s.formationMetrics();
        for(const box of s.shieldBoxes){
          let contacts = 0;
          const aliveIds = s.aliveIds;
          for(let i=0;i<aliveIds.length;i++){
            const id = aliveIds[i];
            const r = (id / s.cols) | 0;
            const c = id - r*s.cols;
            const ex = s.fx + c*stepX;
            const ey = s.fy + r*stepY;
            if(aabb(ex, ey, s.enemyW, s.enemyH, box.x, box.y, box.w, box.h)){
              contacts++;
              if(contacts >= 8) break;
            }
          }
          if(contacts > 0){
            const perEnemy = 3;
            const hits = Math.min(40, contacts * perEnemy);
            this.shields.damageShieldRandom(box.ref, hits);
          }
        }
      }

      // 敵の体当たり（スイープAABB）… aliveIdsのみ
      if(!s.over && !s.ready && !s.clearing){
        const shipX = s.px - s.shipW/2;
        const shipY = s.playerTopY();
        const shipW = s.shipW;
        const shipH = s.shipH;

        const { stepX, stepY } = s.formationMetrics();
        const fx0 = (typeof s.prevFx === "number") ? s.prevFx : s.fx;
        const fy0 = (typeof s.prevFy === "number") ? s.prevFy : s.fy;

        const st = this.enemies.getAliveStats();
        const maxAliveR = st.maxR;

        const aliveIds = s.aliveIds;
        for(let i=0;i<aliveIds.length;i++){
          const id = aliveIds[i];
          const r = (id / s.cols) | 0;
          const c = id - r*s.cols;

          const exA = fx0 + c*stepX;
          const eyA = fy0 + r*stepY;
          const exB = s.fx + c*stepX;
          const eyB = s.fy + r*stepY;

          const sx = Math.min(exA, exB);
          const sy = Math.min(eyA, eyB);
          const sw = Math.max(exA + s.enemyW, exB + s.enemyW) - sx;
          const sh = Math.max(eyA + s.enemyH, eyB + s.enemyH) - sy;

          if(aabb(sx, sy, sw, sh, shipX, shipY, shipW, shipH)){
            if(maxAliveR >= 0){
              const enemyBottom = s.fy + maxAliveR*stepY + s.enemyH;
              const over = enemyBottom - shipY;
              if(over > 0) s.fy -= over;
            }

            const HIT_MS = 260;
            s.hitStop = Math.max(s.hitStop, HIT_MS);

            if(!s._pendingGameOver){
              s._pendingGameOver = true;
              setTimeout(() => {
                s.hitStop = 0;
                s._pendingGameOver = false;
                this.gameOver();
              }, HIT_MS);
            }
            return;
          }
        }
      }

      // 弾 vs シールド
      const pbs = this.pj.playerBullets.active;
      for(let i=pbs.length-1;i>=0;i--){
        const b = pbs[i];
        if(this.shields.shieldHitAndDamage(b.x,b.y,s.BW,s.BH)) this.pj.playerBullets.releaseAt(i);
      }
      const ebs = this.pj.enemyBullets.active;
      for(let i=ebs.length-1;i>=0;i--){
        const b = ebs[i];
        if(this.shields.shieldHitAndDamage(b.x,b.y,s.BW,s.BH)) this.pj.enemyBullets.releaseAt(i);
      }

      // 敵が自機に体当たり（即オーバー）
      if(!s.over){
        const pl = s.px - s.shipW/2;
        const pt = s.playerTopY();
        const {stepX, stepY} = s.formationMetrics();

        const aliveIds = s.aliveIds;
        for(let i=0;i<aliveIds.length;i++){
          const id = aliveIds[i];
          const r = (id / s.cols) | 0;
          const c = id - r*s.cols;
          const ex = s.fx + c*stepX;
          const ey = s.fy + r*stepY;
          if(aabb(ex,ey,s.enemyW,s.enemyH, pl,pt,s.shipW,s.shipH)){
            s.fy = pt - (r * stepY + s.enemyH);
            this.triggerRamming(s.fy);
            return;
          }
        }
      }

      // 自弾 vs 敵
      const {stepX,stepY} = s.formationMetrics();
      for(let i=pbs.length-1;i>=0;i--){
        const b = pbs[i];
        const c = Math.floor((b.x - s.fx)/stepX);
        const r = Math.floor((b.y - s.fy)/stepY);
        if(r>=0 && r<s.rows && c>=0 && c<s.cols && s.hpGrid[r][c] > 0){
          const ex = s.fx + c*stepX;
          const ey = s.fy + r*stepY;
          if(aabb(b.x,b.y,s.BW,s.BH, ex,ey, s.enemyW,s.enemyH)){
            this.pj.playerBullets.releaseAt(i);

            s.hpGrid[r][c]--;
            this.pj.boom(ex+s.enemyW/2, ey+s.enemyH/2);

            if(s.hpGrid[r][c] <= 0){
              this.enemies.onEnemyDamagedOrKilled(r,c);

              s.score += s.rowKillScore(r);
              scoreEl.textContent = s.score;

              if(this.enemies.countAlive()===0 && !s.over && !s.clearing){
                this.nextWave();
                return;
              }
            }
          }
        }
      }

      // 敵弾 vs 自機
      if(!s.over){
        const pl = s.px - s.shipW/2;
        const pt = s.playerTopY();
        for(let i=ebs.length-1;i>=0;i--){
          const b = ebs[i];
          if(aabb(b.x,b.y,s.BW,s.BH, pl,pt, s.shipW,s.shipH)){
            this.pj.enemyBullets.releaseAt(i);
            if(s.invincible===0 && s.safeTimer===0){
              s.life--;
              s.updateLifeHud();
              this.pj.boom(s.px, pt+s.shipH/2);
              s.invincible = 60;
              if(s.life<=0) this.gameOver();
            }
          }
        }
      }
    }
  }

  /* =========================
     Movement / Wave logic
  ========================= */
  class GameLogic {
    constructor(state, enemies, shields, projectiles, collisions){
      this.s = state;
      this.enemies = enemies;
      this.shields = shields;
      this.pj = projectiles;
      this.col = collisions;
    }

    setPaused(next){
      const s = this.s;
      if(s.over) return;
      s.paused = !!next;
      pauseBtn.textContent = s.paused ? "RESUME" : "PAUSE";
      if(s.paused){
        this._msgBeforePause = msgEl.innerHTML;
        msgEl.textContent = "PAUSED";
        s.holdL = false; s.holdR = false;
        Input.stickReset();
        s.playerCanShoot = true;
      }else{
        if(this._msgBeforePause && this._msgBeforePause !== "PAUSED") msgEl.innerHTML = this._msgBeforePause;
        else msgEl.textContent = "";
        this._msgBeforePause = "";
      }
    }
    togglePause(){ this.setPaused(!this.s.paused); }

    reset(){
      const s = this.s;

      this.pj.clearAll();
      s.shieldContactTick = 0;

      msgEl.textContent = "";
      s.score = 0;
      s.wave = 1;
      s.life = 3;

      s.invincible = 0;
      s.safeTimer = 0;

      s.over = false;
      s.clearing = false;

      s.paused = false;
      pauseBtn.textContent = "PAUSE";
      this._msgBeforePause = "";

      s.playerCanShoot = true;
      s.holdL = false; s.holdR = false;

      scoreEl.textContent = "0";
      waveEl.textContent = "1";
      s.updateLifeHud();

      s.px = innerWidth/2;
      s.clampPlayer();

      this.enemies.spawnEnemies();
      this.shields.spawnShields();
      this.col.showReady();
    }

    update(dt){
      const s = this.s;
      if(s.paused) return;

      // ヒット停止
      if(s.hitStop > 0){
        s.hitStop -= dt;
        return;
      }

      // stars
      for(const st of s.stars){
        st.y += st.s * (dt*0.06);
        if(st.y > innerHeight){
          st.y = 0;
          st.x = Math.random() * innerWidth;
        }
      }

      if(s.invincible > 0) s.invincible--;
      if(s.safeTimer > 0) s.safeTimer--;

      // player move
      const sp = s.isMobile ? 3 : 4;
      if(!s.ready && !s.clearing && !s.over){
        if(s.holdL) s.px -= sp;
        if(s.holdR) s.px += sp;
      }
      s.clampPlayer();

      // enemy movement (スイープ用の前回位置)
      s.prevFx = s.fx;
      s.prevFy = s.fy;

      const { stepX, stepY } = s.formationMetrics();
      const remaining = Math.max(1, this.enemies.countAlive());
      const initialCount = s.enemyInitialCount || remaining;
      const ratio = remaining / initialCount;

      // stats（壁判定用）
      const st = this.enemies.getAliveStats();
      const minAliveC = st.minC;
      const maxAliveC = st.maxC;
      const maxAliveR = st.maxR;

      /* =========================================================
         速度調整（最後の1体を運ゲーにしない）
         - ベースは速いまま
         - 最後の1体は 10ms より速くしない（+最低ラインも10ms）
      ========================================================= */
      const baseInterval = 150;
      const minInterval  = 12;   // 終盤の限界（全体）
      const lastOneCap   = 10;   // 最後の1体の上限（これより速くしない）

      const t = 1 - ratio;
      const curve = Math.pow(t, 1.55);

      let moveInterval = baseInterval * (1 - curve) + minInterval * curve;

      const waveSpeedMul = 1 / (1 + (s.wave - 1) * 0.06);
      moveInterval *= waveSpeedMul;

      if (remaining === 1) moveInterval = Math.max(moveInterval, lastOneCap);
      moveInterval = Math.max(10, moveInterval);

      // 横移動量：最後の1体だけ少し落とす（当てられる余地を残す）
      let stepMoveX = 1.35*s.U*(1+(s.wave-1)*0.03);
      if(remaining === 1) stepMoveX *= 0.90;

      const stepDown  = 1.6*s.U;
      const wallPauseMs = 70;

      if(!s.ready && !s.clearing && !s.over){
        s.moveAcc += dt;
        if(s.wallPause > 0){
          const use = Math.min(s.wallPause, s.moveAcc);
          s.wallPause -= use;
          s.moveAcc -= use;
        }
        while(s.moveAcc >= moveInterval){
          s.moveAcc -= moveInterval;
          const margin = 10;
          const nextFx = s.fx + s.dir * stepMoveX;

          const nextAliveLeft  = nextFx + minAliveC * stepX;
          const nextAliveRight = nextFx + maxAliveC * stepX + s.enemyW;

          if (nextAliveRight > innerWidth - margin) {
            const overflow = nextAliveRight - (innerWidth - margin);
            s.fx = nextFx - overflow;
            s.dir = -1;
            s.fy += stepDown;

            const playerTop = s.playerTopY();
            const lowestBottom = s.fy + maxAliveR * stepY + s.enemyH;
            if (lowestBottom >= playerTop) {
              s.fy = playerTop - (maxAliveR * stepY + s.enemyH);
              this.col.triggerRamming(s.fy);
              return;
            }

            s.wallPause = wallPauseMs;
            s.moveAcc = 0;
            break;

          } else if (nextAliveLeft < margin) {
            const overflow = margin - nextAliveLeft;
            s.fx = nextFx + overflow;
            s.dir = 1;
            s.fy += stepDown;

            const playerTop = s.playerTopY();
            const lowestBottom = s.fy + maxAliveR * stepY + s.enemyH;
            if (lowestBottom >= playerTop) {
              s.fy = playerTop - (maxAliveR * stepY + s.enemyH);
              this.col.triggerRamming(s.fy);
              return;
            }

            s.wallPause = wallPauseMs;
            s.moveAcc = 0;
            break;

          } else {
            s.fx = nextFx;
          }
        }
      }

      // enemy anim / shoot
      this.enemies.updateAnim();

      if(!s.ready && !s.clearing && !s.over){
        const prof = s.enemyProfile();
        s.enemyShootTick++;
        if(s.enemyShootTick >= prof.fireInterval){
          s.enemyShootTick = 0;
          this.pj.enemyShoot();
        }
      }

      // projectiles update
      this.pj.update(dt);
    }
  }

  /* =========================
     Renderer
  ========================= */
  class Renderer {
    constructor(state, projectiles){
      this.s = state;
      this.pj = projectiles;
    }
    render(){
      const s = this.s;

      ctx.fillStyle="#000";
      ctx.fillRect(0,0,innerWidth,innerHeight);

      ctx.fillStyle="#fff";
      for(const st of s.stars) ctx.fillRect(st.x,st.y,2,2);

      const sc = s.colors.shield();
      for(const sh of s.shields){
        ctx.fillStyle = sc;
        for(let r=0;r<sh.h;r++){
          for(let c=0;c<sh.w;c++){
            if(sh.bits[r][c]) ctx.fillRect(sh.x + c*s.U, sh.y + r*s.U, s.U, s.U);
          }
        }
      }

      const {stepX,stepY} = s.formationMetrics();
      for(let r=0;r<s.rows;r++){
        for(let c=0;c<s.cols;c++){
          if(s.hpGrid[r][c] <= 0) continue;
          const type = ENEMY_TYPES[r % ENEMY_TYPES.length];
          const bmp = s.enemyFrame ? type.b : type.a;
          const color = s.colors.row[r % s.colors.row.length];
          const x = s.fx + c*stepX;
          const y = s.fy + r*stepY;
          const scale = Math.max(1, Math.round(s.enemyW/7));
          drawBitmap(bmp, x, y, scale, color);

          if(s.hpGrid[r][c] >= 2){
            ctx.fillStyle="rgba(255,255,255,.65)";
            ctx.fillRect(x, y-3, Math.max(10, s.enemyW*0.30), 2);
          }
        }
      }

      drawBitmap(SHIP, s.px - s.shipW/2, s.playerTopY(), s.U, s.colors.player());

      ctx.fillStyle="cyan";
      for(const b of this.pj.playerBullets.active) ctx.fillRect(b.x,b.y,s.BW,s.BH);

      ctx.fillStyle="orange";
      for(const b of this.pj.enemyBullets.active) ctx.fillRect(b.x,b.y,s.BW,s.BH);

      ctx.fillStyle="orange";
      for(const p of this.pj.booms.active) ctx.fillRect(p.x,p.y,4,4);

      if(s.paused){
        ctx.fillStyle="rgba(0,0,0,.25)";
        ctx.fillRect(0,0,innerWidth,innerHeight);
      }
    }
  }

  /* =========================
     Input（ほぼそのまま）
  ========================= */
  const state = new GameState();
  const enemies = new EnemySystem(state);
  const shields = new ShieldSystem(state);

  // projectiles は enemies/shields 参照するので後で構築
  let projectiles, collisions, logic, renderer;

  const Input = {
    stick: { baseCx:0, baseCy:0, radius:52, dx:0 },
    stickTouchActive:false,

    updateStickGeometry(){
      const r = stickBase.getBoundingClientRect();
      this.stick.baseCx = r.left + r.width/2;
      this.stick.baseCy = r.top  + r.height/2;
    },

    setKnobPos(x,y){
      const w = stickKnob.offsetWidth || 74;
      const h = stickKnob.offsetHeight || 74;
      stickKnob.style.left = (x - w/2) + "px";
      stickKnob.style.top  = (y - h/2) + "px";
    },

    applyStick(){
      const dead = 0.18;
      if(Math.abs(this.stick.dx) < dead){
        state.holdL = false; state.holdR = false;
        return;
      }
      if(this.stick.dx < 0){
        state.holdL = true; state.holdR = false;
      }else{
        state.holdR = true; state.holdL = false;
      }
    },

    stickReset(){
      this.stickTouchActive = false;
      this.stick.dx = 0;
      state.holdL = false;
      state.holdR = false;
      this.updateStickGeometry();
      this.setKnobPos(this.stick.baseCx, this.stick.baseCy);
    },

    stickMoveTouch(t){
      const vx = t.clientX - this.stick.baseCx;
      const max = this.stick.radius;
      const cl = Math.min(Math.abs(vx), max);
      const dx = vx < 0 ? -cl : cl;

      this.setKnobPos(this.stick.baseCx + dx, this.stick.baseCy);
      this.stick.dx = clamp(vx / max, -1, 1);
      this.applyStick();
    },

    updateControlsVisibility(){
      controls.style.display = state.isMobile ? "block" : "none";
      this.updateStickGeometry();
      this.setKnobPos(this.stick.baseCx, this.stick.baseCy);
    }
  };

  /* =========================
     Wiring / Events
  ========================= */
  function rebuildSystems(){
    // systems は state を共有しつつ、依存順に組む
    projectiles = new ProjectileSystem(state, enemies, shields);
    collisions  = new CollisionSystem(state, enemies, shields, projectiles);
    logic       = new GameLogic(state, enemies, shields, projectiles, collisions);
    renderer    = new Renderer(state, projectiles);
  }

  pauseBtn.addEventListener("click", (e)=>{
    e.preventDefault();
    logic.togglePause();
  }, {passive:false});

  addEventListener("keydown",(e)=>{
    if(e.key==="p"||e.key==="P"||e.key==="Escape"){
      logic.togglePause();
      return;
    }
    if(state.paused) return;

    if(state.over && e.key==="Enter"){
      logic.reset();
      return;
    }

    if(e.code==="ArrowLeft") state.holdL=true;
    if(e.code==="ArrowRight") state.holdR=true;

    if(e.code==="KeyA" && state.playerCanShoot){
      state.playerCanShoot = false;
      projectiles.shootPlayerOnce();
    }
  });

  addEventListener("keyup",(e)=>{
    if(state.paused) return;
    if(e.code==="ArrowLeft") state.holdL=false;
    if(e.code==="ArrowRight") state.holdR=false;
    if(e.code==="KeyA") state.playerCanShoot = true;
  });

  ["touchstart","touchmove","touchend"].forEach(t=>{
    document.addEventListener(t, e=>{
      if(e.target && e.target.id === "shootBtn") e.preventDefault();
    }, {passive:false});
  });

  const onStickStart = (e) => {
    if(!state.isMobile || state.paused || state.over) return;
    Input.stickTouchActive = true;
    Input.updateStickGeometry();
    if(e.touches && e.touches[0]) Input.stickMoveTouch(e.touches[0]);
    e.preventDefault();
    e.stopPropagation();
  };

  stickBase.addEventListener("touchstart", onStickStart, {passive:false});
  stickKnob.addEventListener("touchstart", onStickStart, {passive:false});

  window.addEventListener("touchmove",(e)=>{
    if(!Input.stickTouchActive || state.paused) return;
    if(e.touches && e.touches[0]) Input.stickMoveTouch(e.touches[0]);
    e.preventDefault();
    e.stopPropagation();
  }, {passive:false});

  const endStickTouch = (e) => {
    if(!Input.stickTouchActive) return;
    Input.stickReset();
    e.preventDefault();
    e.stopPropagation();
  };
  window.addEventListener("touchend", endStickTouch, {passive:false});
  window.addEventListener("touchcancel", endStickTouch, {passive:false});

  const shootOnceOnTouch = (e) => {
    if(!state.isMobile || state.paused) return;
    if(state.over){ logic.reset(); return; }

    shootBtn.blur();
    if(document.activeElement) document.activeElement.blur();

    projectiles.shootPlayerOnce();

    e.preventDefault();
    e.stopPropagation();
  };

  shootBtn.addEventListener("touchstart", shootOnceOnTouch, {passive:false});
  shootBtn.addEventListener("touchend", (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});
  shootBtn.addEventListener("touchcancel", (e)=>{ e.preventDefault(); e.stopPropagation(); }, {passive:false});

  let resizeQueued=false;
  addEventListener("resize",()=>{
    if(resizeQueued) return;
    resizeQueued=true;
    requestAnimationFrame(()=>{
      resizeQueued=false;

      resizeCanvas();

      const oldIsMobile = state.isMobile;
      state.U = calcU();
      state.isMobile = isCoarse();
      const bpChanged = (oldIsMobile !== state.isMobile);

      state.recalcSizes();
      state.resetStars();
      state.clampPlayer();
      Input.updateControlsVisibility();

      if(bpChanged){
        // ブレイクポイント変化時は完全リセット（操作系/当たり判定のズレ防止）
        logic.reset();
        return;
      }

      shields.relayoutShields();

      const {totalW, baseY} = state.formationMetrics();
      state.fx = (innerWidth - totalW)/2;
      state.fy = baseY;

      if(state.paused) Input.stickReset();
    });
  });

  function loop(){
    const now = performance.now();
    const dt = Math.min(34, now - (loop._last || now));
    loop._last = now;

    logic.update(dt);
    collisions.detect();
    renderer.render();

    requestAnimationFrame(loop);
  }

  // boot
  resizeCanvas();
  rebuildSystems();

  state.recalcSizes();
  state.resetStars();
  Input.updateControlsVisibility();
  Input.stickReset();
  state.updateLifeHud();
  logic.reset();
  loop();

})();
</script>
</body>
</html>
