<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Invader Stable v6 (Full Canvas) + Stick + Pause</title>
<style>
  html,body{margin:0;padding:0;background:#000;overflow:hidden;touch-action:none;}
  canvas{position:fixed;inset:0;display:block;touch-action:none;pointer-events:auto}

  #hud{
    position:fixed;top:8px;left:8px;z-index:10;color:#fff;
    font:14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    user-select:none;pointer-events:none;
  }

  #pauseBtn{
    position:fixed;top:10px;right:10px;z-index:60;
    padding:8px 12px;font:700 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    color:#fff;background:rgba(0,0,0,.55);
    border:2px solid rgba(255,255,255,.25);border-radius:10px;
    cursor:pointer;pointer-events:auto;user-select:none;
  }

  #msg{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    color:#fff;font:700 40px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    text-shadow:0 2px 0 rgba(0,0,0,.5);
    z-index:40;pointer-events:none;text-align:center;white-space:pre-line;
  }

  /* ===== Mobile controls ===== */
  .controls{position:fixed;inset:0;z-index:50;pointer-events:none}

  #stickBase,#stickKnob{
    position:fixed;border-radius:50%;
    pointer-events:auto;touch-action:none;user-select:none;
  }
  #stickBase{
    width:140px;height:140px;left:22px;bottom:22px;
    background:rgba(40,40,40,.55);
    border:2px solid rgba(255,255,255,.25);
  }
  #stickKnob{
    width:74px;height:74px;left:22px;bottom:22px;
    background:rgba(0,0,0,.65);
    border:2px solid rgba(255,255,255,.20);
  }

  #shootBtn{
    position:fixed;width:120px;height:120px;
    right:22px;bottom:28px;border-radius:50%;
    pointer-events:auto;touch-action:none;
    background:radial-gradient(circle at 30% 30%,rgba(255,255,255,.35),rgba(255,0,0,.9));
    border:2px solid rgba(255,255,255,.25);
  }
  #shootLabel{
    position:fixed;right:22px;bottom:160px;
    color:#fff;font:800 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 10px;border:2px solid rgba(255,255,255,.25);
    border-radius:10px;background:rgba(0,0,0,.45);pointer-events:none;
  }

  @media (min-width:900px){
    .controls{display:none;}
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div id="hud">
  SCORE <span id="score">0</span> /
  WAVE <span id="wave">1</span><br>
  LIFE <span id="life">❤️❤️❤️</span>
</div>

<button id="pauseBtn" type="button">PAUSE</button>
<div id="msg"></div>

<div class="controls" id="controls">
  <div id="stickBase"></div>
  <div id="stickKnob"></div>
  <div id="shootBtn"></div>
  <div id="shootLabel">SHOT</div>
</div>

<script>
/* =========================
   基本設定
========================= */
const cv = document.getElementById("cv");
const ctx = cv.getContext("2d", { alpha:false });

function resizeCanvas(){ cv.width = innerWidth; cv.height = innerHeight; }
resizeCanvas();

function calcU(){ if (innerWidth>=1200) return 7; if (innerWidth>=800) return 6; return 4; }
let U = calcU();
let isMobile = innerWidth < 800;

function getCols(){ return 11; }
function getRows(){ return 5; }

const scoreEl = document.getElementById("score");
const waveEl  = document.getElementById("wave");
const lifeEl  = document.getElementById("life");
const msgEl   = document.getElementById("msg");

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function aabb(ax,ay,aw,ah,bx,by,bw,bh){
  return !(ax+aw<bx || ax>bx+bw || ay+ah<by || ay>by+bh);
}

/* =========================
   ポーズ
========================= */
const pauseBtn = document.getElementById("pauseBtn");
let paused = false;
let msgBeforePause = "";

function setPaused(next){
  if(over) return;
  paused = !!next;
  pauseBtn.textContent = paused ? "RESUME" : "PAUSE";
  if(paused){
    msgBeforePause = msgEl.innerHTML;
    msgEl.textContent = "PAUSED";
    holdL = false; holdR = false;
    stopShooting(); stickReset(); canShoot = true;
  }else{
    if(msgBeforePause && msgBeforePause!=="PAUSED") msgEl.innerHTML = msgBeforePause;
    else msgEl.textContent = "";
    msgBeforePause = "";
  }
}
function togglePause(){ setPaused(!paused); }
pauseBtn.addEventListener("click", togglePause);

/* =========================
   スプライト
========================= */
const SHIP = [
  "00000100000","00001110000","00001110000",
  "01111111110","11111111111","11111111111","11111111111"
];

const ENEMY_TYPES = [
  { a:["0100010","1111111","1011101","0100010"], b:["0100010","1111111","0101010","1010101"] },
  { a:["0011100","0111110","1101011","0111110"], b:["0011100","1111111","0101010","1010101"] },
  { a:["0110110","1111111","0101010","1010101"], b:["0011100","0111110","1101011","0111110"] },
  { a:["0011100","1111111","1010101","0100010"], b:["0011100","0111110","0101010","1010101"] }
];

const SHIELD = [
  "00111100","01111110","11111111","11111111","11111111","11000011"
];

function drawBitmap(lines, x, y, scale, color){
  ctx.fillStyle = color;
  for(let r=0;r<lines.length;r++){
    const row = lines[r];
    for(let c=0;c<row.length;c++){
      if(row[c]==="1") ctx.fillRect(x+c*scale, y+r*scale, scale, scale);
    }
  }
}

/* =========================
   色
========================= */
function shieldColor(){ return "#ff3333"; }
function playerColor(){ return "#44ff88"; }
const ROW_COLORS = ["#ff4d4d","#ffb84d","#ffff4d","#4dff4d","#4dd2ff"];

/* =========================
   サイズ
========================= */
let shipW=0, shipH=0, enemyW=0, enemyH=0, shieldW=0, shieldH=0;

function recalcSizes(){
  shipW = SHIP[0].length * U;
  shipH = SHIP.length * U;

  const cols = getCols();
  const margin = 12;
  const minGapX = 0.90*U;
  const availW = Math.max(120, innerWidth - margin*2);
  const maxEnemyW = (availW - (cols-1)*minGapX) / cols;
  const scale = isMobile ? 0.78 : 0.86;
  const targetW = maxEnemyW * scale;

  enemyW = clamp(targetW, 2.6*U, 5.5*U);
  enemyH = enemyW * (4/7);

  shieldW = 8*U;
  shieldH = 6*U;
}
recalcSizes();

/* =========================
   背景スター
========================= */
let stars = [];
function resetStars(){
  stars = [...Array(120)].map(()=>({x:Math.random()*innerWidth,y:Math.random()*innerHeight,s:0.6+Math.random()*1.2}));
}
resetStars();

/* =========================
   ゲーム状態
========================= */
let score=0, wave=1, life=3;
let ready=true, clearing=false, over=false;
let invincible=0, safeTimer=0;
let canShoot=true;
let holdL=false, holdR=false;

function updateLifeHud(){ lifeEl.textContent = "❤️".repeat(Math.max(0, life)); }

/* =========================
   自機
========================= */
const playerBottomPx = 70;
let px = innerWidth/2;

function playerTopY(){ return innerHeight - playerBottomPx - shipH; }
function clampPlayer(){ px = clamp(px, shipW/2, innerWidth - shipW/2); }

/* =========================
   敵隊列
========================= */
let cols = getCols(), rows = getRows();
let fx=0, fy=0, dir=1;
let enemyInitialCount = 0;
let enemyFrame = 0, enemyAnimTick = 0, enemyShootTick = 0;
let moveAcc = 0, wallPause = 0;
let aliveGrid = [];

function formationMetrics(){
  const minGapX = 0.90*U, minGapY = 1.10*U;
  const stepX = enemyW + minGapX;
  const stepY = enemyH + minGapY;
  const totalW = cols*enemyW + (cols-1)*minGapX;
  const baseY = Math.max(90, innerHeight*0.22);
  return { stepX, stepY, totalW, baseY };
}

function countAlive(){
  let n=0;
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(aliveGrid[r][c]) n++;
  return n;
}

function spawnEnemies(){
  cols = getCols(); rows = getRows();
  aliveGrid = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>true));
  const { totalW, baseY } = formationMetrics();
  fx = (innerWidth - totalW)/2; fy = baseY; dir = 1;
  enemyInitialCount = rows*cols;
  moveAcc = 0; wallPause = 0; enemyFrame = 0; enemyAnimTick = 0; enemyShootTick = 0;
}

/* =========================
   盾
========================= */
let shields = [];
function buildShieldBits(){
  const h = SHIELD.length, w = SHIELD[0].length;
  const bits = Array.from({length:h}, (_,r)=>Array.from({length:w},(_,c)=>SHIELD[r][c]==="1"));
  return {bits,w,h};
}
function spawnShields(){
  shields = [];
  const baseY = playerTopY() - 80;
  const xs = [0.2,0.4,0.6,0.8];
  const proto = buildShieldBits();
  for(let i=0;i<xs.length;i++){
    const x = innerWidth*xs[i] - shieldW/2, y = baseY;
    const bits = proto.bits.map(row=>row.slice());
    shields.push({x,y,bits,w:proto.w,h:proto.h});
  }
}
function shieldHitAndDamage(bx,by,bw,bh){
  for(const s of shields){
    if(!aabb(bx,by,bw,bh, s.x,s.y, shieldW,shieldH)) continue;
    const rx = clamp(Math.floor(((bx+bw/2)-s.x)/U),0,s.w-1);
    const ry = clamp(Math.floor(((by+bh/2)-s.y)/U),0,s.h-1);
    const cand=[];
    for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
      const cx=rx+dx, cy=ry+dy;
      if(cy>=0&&cy<s.h&&cx>=0&&cx<s.w&&s.bits[cy][cx]) cand.push([cy,cx]);
    }
    if(cand.length){
      const [cy,cx]=cand[(Math.random()*cand.length)|0];
      s.bits[cy][cx]=false;
    }
    return true;
  }
  return false;
}

/* =========================
   弾・爆発
========================= */
const bullets=[], ebullets=[];
const BW=4, BH=10;
const booms=[];
function boom(x,y){
  for(let i=0;i<10;i++) booms.push({x,y,vx:(Math.random()-.5)*5,vy:(Math.random()-.5)*5,t:18});
}

/* =========================
   射撃
========================= */
function shoot(){
  if(paused) return;
  if(ready||clearing||over||!canShoot) return;
  canShoot=false;
  bullets.push({x:px-BW/2,y:playerTopY(),v:-10});
}
function enemyShoot(){
  if(paused) return;
  if(ready||clearing||over) return;
  const alive=[];
  for(let r=0;r<rows;r++)for(let c=0;c<cols;c++) if(aliveGrid[r][c]) alive.push([r,c]);
  if(!alive.length) return;
  const [r,c]=alive[(Math.random()*alive.length)|0];
  const {stepX,stepY}=formationMetrics();
  const ex=fx+c*stepX, ey=fy+r*stepY;
  ebullets.push({x:ex+enemyW/2-BW/2,y:ey+enemyH,v:isMobile?5:7});
}

/* =========================
   READY / CLEAR / GAMEOVER
========================= */
function showReady(){
  clearTimeout(window._msgTimer);
  if(!paused) msgEl.textContent="";
  ready=true; safeTimer=Math.floor(wave*0.5*60);
  window._msgTimer=setTimeout(()=>{ if(!over&&!paused) msgEl.textContent=""; ready=false; },900);
}
function nextWave(){
  clearing=true; if(!paused) msgEl.textContent="CLEAR!";
  setTimeout(()=>{
    if(paused) return;
    msgEl.textContent=""; wave++; waveEl.textContent=wave; clearing=false;
    spawnEnemies(); spawnShields(); showReady();
  },900);
}
function gameOver(){
  if(over) return;
  over=true; paused=false; pauseBtn.textContent="PAUSE";
  msgEl.innerHTML="GAME OVER<br>Tap or Enter";
}

/* =========================
   リセット
========================= */
function reset(){
  bullets.length=0; ebullets.length=0; booms.length=0;
  msgEl.textContent="";
  score=0; wave=1; life=3; invincible=0; safeTimer=0; over=false; clearing=false;
  paused=false; pauseBtn.textContent="PAUSE"; msgBeforePause="";
  stopShooting(); stickReset();
  scoreEl.textContent="0"; waveEl.textContent="1"; updateLifeHud();
  px=innerWidth/2; clampPlayer();
  spawnEnemies(); spawnShields(); showReady();
}

/* =========================
   ロジック
========================= */
function enemyProfile(){
  const fireInterval=Math.max(40,Math.floor(140-(wave-1)*10));
  return {fireInterval};
}

function updateLogic(dt){
  if(paused) return;

  for(const s of stars){
    s.y+=s.s*(dt*0.06);
    if(s.y>innerHeight){s.y=0;s.x=Math.random()*innerWidth;}
  }

  if(invincible>0) invincible--;
  if(safeTimer>0) safeTimer--;

  const sp=isMobile?3:4;
  if(!ready&&!clearing&&!over){
    if(holdL) px-=sp;
    if(holdR) px+=sp;
  }
  clampPlayer();

  const {totalW}=formationMetrics();
  const remaining=Math.max(1,countAlive());
  const initialCount=enemyInitialCount||remaining;
  const ratio=remaining/initialCount;
  const baseInterval=260,minInterval=80;
  let moveInterval=baseInterval*ratio+minInterval*(1-ratio);
  moveInterval=Math.max(minInterval,moveInterval)/(1+(wave-1)*0.06);
  const stepMoveX=0.55*U*(1+(wave-1)*0.02);
  const stepDown=0.60*U;
  const wallPauseMs=140;

  if(!ready&&!clearing&&!over){
    moveAcc+=dt;
    if(wallPause>0){
      const use=Math.min(wallPause,moveAcc);
      wallPause-=use; moveAcc-=use;
    }
    while(moveAcc>=moveInterval){
      moveAcc-=moveInterval;
      const margin=10;
      const nextFx=fx+dir*stepMoveX;
      const nextLeft=nextFx, nextRight=nextFx+totalW;
      if(nextRight>innerWidth-margin||nextLeft<margin){
        dir*=-1;
        const enemyMaxY=playerTopY()-120;
        const stepYFix=7*U;
        const maxFy=enemyMaxY-(rows-1)*stepYFix;
        fy=Math.min(fy+stepDown,maxFy);
        wallPause=wallPauseMs;
      }else fx=nextFx;
    }
  }

  enemyAnimTick++;
  if(enemyAnimTick>=28){ enemyAnimTick=0; enemyFrame=1-enemyFrame; }

  if(!ready&&!clearing&&!over){
    const prof=enemyProfile();
    enemyShootTick++;
    if(enemyShootTick>=prof.fireInterval){
      enemyShootTick=0; enemyShoot();
    }
  }

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i]; b.y+=b.v*(dt*0.06);
    if(b.y<-20) bullets.splice(i,1);
  }
  for(let i=ebullets.length-1;i>=0;i--){
    const b=ebullets[i]; b.y+=b.v*(dt*0.06);
    if(b.y>innerHeight+30) ebullets.splice(i,1);
  }

  for(let i=booms.length-1;i>=0;i--){
    const p=booms[i]; p.x+=p.vx; p.y+=p.vy; p.t--;
    if(p.t<=0) booms.splice(i,1);
  }
}

function detectCollisions(){
  if(paused) return;

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(shieldHitAndDamage(b.x,b.y,BW,BH)) bullets.splice(i,1);
  }
  for(let i=ebullets.length-1;i>=0;i--){
    const b=ebullets[i];
    if(shieldHitAndDamage(b.x,b.y,BW,BH)) ebullets.splice(i,1);
  }

  const {stepX,stepY}=formationMetrics();
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    const c=Math.floor((b.x-fx)/stepX);
    const r=Math.floor((b.y-fy)/stepY);
    if(r>=0&&r<rows&&c>=0&&c<cols&&aliveGrid[r][c]){
      const ex=fx+c*stepX, ey=fy+r*stepY;
      if(aabb(b.x,b.y,BW,BH,ex,ey,enemyW,enemyH)){
        aliveGrid[r][c]=false; bullets.splice(i,1);
        boom(ex+enemyW/2,ey+enemyH/2);
        score+=100; scoreEl.textContent=score;
        if(countAlive()===0&&!over&&!clearing) nextWave();
      }
    }
  }

  if(!over){
    const pl=px-shipW/2, pt=playerTopY();
    for(let i=ebullets.length-1;i>=0;i--){
      const b=ebullets[i];
      if(aabb(b.x,b.y,BW,BH,pl,pt,shipW,shipH)){
        ebullets.splice(i,1);
        if(invincible===0&&safeTimer===0){
          life--; updateLifeHud(); boom(px,pt+shipH/2); invincible=60;
          if(life<=0) gameOver();
        }
      }
    }
  }
}

function render(){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,innerWidth,innerHeight);

  ctx.fillStyle="#fff";
  for(const s of stars) ctx.fillRect(s.x,s.y,2,2);

  const sc=shieldColor();
  for(const s of shields){
    ctx.fillStyle=sc;
    for(let r=0;r<s.h;r++)for(let c=0;c<s.w;c++)
      if(s.bits[r][c]) ctx.fillRect(s.x+c*U,s.y+r*U,U,U);
  }

  const {stepX,stepY}=formationMetrics();
  for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
    if(!aliveGrid[r][c]) continue;
    const type=ENEMY_TYPES[r%ENEMY_TYPES.length];
    const bmp=enemyFrame?type.b:type.a;
    const color=ROW_COLORS[r%ROW_COLORS.length];
    const x=fx+c*stepX, y=fy+r*stepY;
    const scale=Math.max(1,Math.round(enemyW/7));
    drawBitmap(bmp,x,y,scale,color);
  }

  drawBitmap(SHIP,px-shipW/2,playerTopY(),U,playerColor());

  ctx.fillStyle="cyan"; for(const b of bullets) ctx.fillRect(b.x,b.y,BW,BH);
  ctx.fillStyle="orange"; for(const b of ebullets) ctx.fillRect(b.x,b.y,BW,BH);
  ctx.fillStyle="orange"; for(const p of booms) ctx.fillRect(p.x,p.y,4,4);

  if(paused){
    ctx.fillStyle="rgba(0,0,0,.25)";
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }
}

/* =========================
   PC入力（Aで発射のみ／Space無効）
========================= */
addEventListener("keydown",(e)=>{
  if(e.key==="p"||e.key==="P"||e.key==="Escape"){ togglePause(); return; }
  if(paused) return;
  if(over && e.key==="Enter") reset();

  if(e.code==="ArrowLeft") holdL=true;
  if(e.code==="ArrowRight") holdR=true;

  if(e.code==="KeyA") shoot(); // ★ Aのみ発射
});
addEventListener("keyup",(e)=>{
  if(paused) return;
  if(e.code==="ArrowLeft") holdL=false;
  if(e.code==="ArrowRight") holdR=false;
  if(e.code==="KeyA") canShoot=true;
});

/* =========================
   モバイル：アナログスティック＋SHOT
========================= */
const controls=document.getElementById("controls");
const stickBase=document.getElementById("stickBase");
const stickKnob=document.getElementById("stickKnob");
const shootBtn=document.getElementById("shootBtn");

let stick={active:false,pid:null,baseCx:0,baseCy:0,radius:52,dx:0};

function setKnobPos(x,y){
  const w=stickKnob.offsetWidth||74, h=stickKnob.offsetHeight||74;
  stickKnob.style.left=(x-w/2)+"px";
  stickKnob.style.top=(y-h/2)+"px";
}
function updateStickGeometry(){
  const r=stickBase.getBoundingClientRect();
  stick.baseCx=r.left+r.width/2;
  stick.baseCy=r.top+r.height/2;
  setKnobPos(stick.baseCx,stick.baseCy);
}
function applyStick(){
  const dead=0.18;
  if(Math.abs(stick.dx)<dead){ holdL=false; holdR=false; return; }
  if(stick.dx<0){ holdL=true; holdR=false; }
  else{ holdR=true; holdL=false; }
}
function stickReset(){
  stick.active=false; stick.pid=null; stick.dx=0;
  holdL=false; holdR=false;
  try{ updateStickGeometry(); }catch(e){}
}

function stickDown(e){
  if(!isMobile||paused||over) return;
  if(stick.active) return;
  stick.active=true; stick.pid=e.pointerId;
  stickKnob.setPointerCapture(e.pointerId);
  updateStickGeometry();
  stickMove(e); e.preventDefault();
}
function stickMove(e){
  if(!isMobile||paused||!stick.active||e.pointerId!==stick.pid) return;
  const vx=e.clientX-stick.baseCx, vy=e.clientY-stick.baseCy;
  const len=Math.hypot(vx,vy), max=stick.radius;
  const nx=len?vx/len:0, ny=len?vy/len:0;
  const cl=Math.min(len,max);
  setKnobPos(stick.baseCx+nx*cl, stick.baseCy+ny*cl);
  stick.dx=clamp(vx/max,-1,1);
  applyStick();
}
function stickUp(e){
  if(!isMobile||e.pointerId!==stick.pid) return;
  stickReset(); e.preventDefault();
}

let shootInterval=null;
function startShooting(){
  if(paused) return;
  if(over){ reset(); return; }
  canShoot=true; shoot();
  stopShooting();
  shootInterval=setInterval(()=>{
    if(paused||over) return;
    canShoot=true; shoot();
  },120);
}
function stopShooting(){
  if(shootInterval){ clearInterval(shootInterval); shootInterval=null; }
  canShoot=true;
}

function shootDown(e){
  if(!isMobile||paused) return;
  shootBtn.setPointerCapture(e.pointerId);
  startShooting(); e.preventDefault();
}
function shootUp(e){
  if(!isMobile) return;
  stopShooting(); e.preventDefault();
}

stickKnob.addEventListener("pointerdown",stickDown);
window.addEventListener("pointermove",stickMove,{passive:false});
window.addEventListener("pointerup",stickUp,{passive:false});
window.addEventListener("pointercancel",stickUp,{passive:false});

shootBtn.addEventListener("pointerdown",shootDown,{passive:false});
shootBtn.addEventListener("pointerup",shootUp,{passive:false});
shootBtn.addEventListener("pointercancel",shootUp,{passive:false});

function updateControlsVisibility(){
  controls.style.display = (innerWidth<900) ? "block" : "none";
  updateStickGeometry();
}
updateControlsVisibility();

/* =========================
   resize
========================= */
let resizeQueued=false;
addEventListener("resize",()=>{
  if(resizeQueued) return;
  resizeQueued=true;
  requestAnimationFrame(()=>{
    resizeQueued=false;
    resizeCanvas();
    const oldU=U, oldIsMobile=isMobile, oldCols=cols, oldRows=rows;
    U=calcU(); isMobile=innerWidth<800; recalcSizes();
    const bpChanged=(oldIsMobile!==isMobile)||(oldCols!==getCols())||(oldRows!==getRows());
    resetStars(); clampPlayer(); updateControlsVisibility();
    if(bpChanged){ reset(); return; }
    if(oldU!==U) spawnShields();
    const {totalW,baseY}=formationMetrics();
    fx=(innerWidth-totalW)/2; fy=baseY;
    if(paused) stickReset();
  });
});

/* =========================
   ループ
========================= */
function loop(){
  const now=performance.now();
  const dt=Math.min(34, now-(loop._last||now));
  loop._last=now;
  updateLogic(dt);
  detectCollisions();
  render();
  requestAnimationFrame(loop);
}

/* =========================
   START
========================= */
reset();
loop();
</script>
</body>
</html>
